---
title: "生物学年龄计算方法比较"
author: "你的名字"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: united
    highlight: tango
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 8,
  fig.height = 6
)
```

## 简介

本文档演示两种生物学年龄计算方法：
1. **KDM (Klemera-Doubal Method)** - 基于多个生物指标的线性回归方法
2. **Phenotypic Age (表型年龄)** - Levine 2018 年提出的方法

## 1. KDM 方法计算生物学年龄

### 1.1 模拟数据

```{r kdm-data, echo=TRUE}
set.seed(123)
n <- 1000

# 模拟时间年龄：40～80岁
age <- runif(n, 40, 80)

# 各指标与年龄"有点关系"的模拟
sbp        <- 90  + 0.8 * age + rnorm(n, 0, 10)
dbp        <- 60  + 0.2 * age + rnorm(n, 0, 8)
bmi        <- 20  + 0.05 * age + rnorm(n, 0, 3)
chol       <- 160 + 1.0 * (age - 50)/10 + rnorm(n, 0, 20)
glucose    <- 80  + 0.6 * (age - 50)/10 + rnorm(n, 0, 10)
creatinine <- 0.7 + 0.01 * (age - 50) + rnorm(n, 0, 0.15)
albumin    <- 45  - 0.1 * (age - 50) + rnorm(n, 0, 3)
crp        <- exp(-1 + 0.03 * (age - 50) + rnorm(n, 0, 0.5))

dat_kdm <- data.frame(
  id    = 1:n,
  age   = age,
  sbp   = sbp,
  dbp   = dbp,
  bmi   = bmi,
  chol  = chol,
  glu   = glucose,
  crea  = creatinine,
  alb   = albumin,
  crp   = crp
)

str(dat_kdm)
head(dat_kdm)
```

### 1.2 使用 KDM 计算生物学年龄

```{r kdm-calculation, echo=TRUE}
# 选取要用于 KDM 的指标
bio_vars <- c("sbp", "dbp", "bmi", "chol", "glu", "crea", "alb", "crp")

# 1) 对每个指标做线性回归：x_j ~ age
k_vec   <- numeric(length(bio_vars))
q_vec   <- numeric(length(bio_vars))
sigma_j <- numeric(length(bio_vars))

for (j in seq_along(bio_vars)) {
  x <- dat_kdm[[bio_vars[j]]]
  fit <- lm(x ~ age, data = dat_kdm)
  k_vec[j]   <- coef(fit)[1]
  q_vec[j]   <- coef(fit)[2]
  sigma_j[j] <- sd(residuals(fit))
}

names(k_vec)   <- bio_vars
names(q_vec)   <- bio_vars
names(sigma_j) <- bio_vars

cat("截距 k_j:\n")
print(k_vec)
cat("\n斜率 q_j:\n")
print(q_vec)
cat("\n残差标准差 sigma_j:\n")
print(sigma_j)

# 2) 计算反推年龄 A_ij
X_mat <- as.matrix(dat_kdm[, bio_vars])
k_mat <- matrix(k_vec, nrow = nrow(X_mat), ncol = length(bio_vars), byrow = TRUE)
q_mat <- matrix(q_vec, nrow = nrow(X_mat), ncol = length(bio_vars), byrow = TRUE)
A_mat <- (X_mat - k_mat) / q_mat

# 3) 计算权重 w_j
w_vec <- (q_vec^2) / (sigma_j^2)
cat("\n权重 w_j:\n")
print(w_vec)

sum_w <- sum(w_vec)

# 4) 年龄的方差
s2 <- var(dat_kdm$age)

# 5) 计算 KDM 生物学年龄
weighted_age_component <- A_mat %*% w_vec
BA_kdm <- (weighted_age_component + dat_kdm$age / s2) / (sum_w + 1 / s2)

dat_kdm$BA_KDM <- as.numeric(BA_kdm)

cat("\nKDM 生物学年龄的前10个值:\n")
head(dat_kdm[, c("id", "age", "BA_KDM")], 10)

# 简单画图
plot(dat_kdm$age, dat_kdm$BA_KDM,
     xlab = "实际年龄", ylab = "KDM生物学年龄",
     main = "实际年龄 vs KDM生物学年龄",
     col = rgb(0.2, 0.4, 0.8, 0.5), pch = 19)
abline(0, 1, col = "red", lwd = 2)
grid()
```

### 1.3 生物学年龄加速情况

```{r kdm-acceleration, echo=TRUE}
dat_kdm$BA_high <- ifelse(dat_kdm$BA_KDM > dat_kdm$age, 1, 0)

# 统计
cat("生物学年龄高于实际年龄的比例:\n")
table(dat_kdm$BA_high)
prop.table(table(dat_kdm$BA_high)) * 100
```

## 2. Phenotypic Age 方法

### 2.1 模拟数据

```{r phenotypic-data, echo=TRUE}
set.seed(123)
n <- 1000

age <- runif(n, 40, 80)

# 模拟 9 个临床指标
WBC   <- pmax(rnorm(n, 6 + 0.02 * (age - 50), 1.2), 2)
Lymph <- pmin(pmax(rnorm(n, 30 - 0.1 * (age - 50), 5), 5), 60)
MCV   <- rnorm(n, 90 + 0.1 * (age - 50), 5)
RDW   <- rnorm(n, 13 + 0.03 * (age - 50), 1.0)
Glucose <- pmax(rnorm(n, 95 + 0.5 * (age - 50), 15), 60)
Creatinine <- pmax(rnorm(n, 0.8 + 0.01 * (age - 50), 0.2), 0.4)
Albumin <- rnorm(n, 4.5 - 0.01 * (age - 50), 0.3)
ALP    <- pmax(rnorm(n, 80 + 0.5 * (age - 50), 20), 20)
CRP    <- exp(rnorm(n, -1 + 0.03 * (age - 50), 0.6))

dat_pheno <- data.frame(
  id    = 1:n,
  age   = age,
  WBC   = WBC,
  Lymph = Lymph,
  MCV   = MCV,
  RDW   = RDW,
  Glucose = Glucose,
  Creatinine = Creatinine,
  Albumin = Albumin,
  ALP   = ALP,
  CRP   = CRP
)

str(dat_pheno)
head(dat_pheno)
```

### 2.2 计算 Phenotypic Age

```{r phenotypic-calculation, echo=TRUE}
# 按 Levine (2018) 公式计算
xb <- -19.907 +
  0.0336  * dat_pheno$age +
  0.0095  * log(dat_pheno$ALP) +
  0.1953  * log(dat_pheno$CRP) +
  0.0954  * log(dat_pheno$Glucose) +
  -0.0120 * dat_pheno$Albumin +
  0.0268  * dat_pheno$Creatinine +
  0.3306  * dat_pheno$RDW +
  0.00188 * dat_pheno$MCV +
  0.0554  * dat_pheno$WBC +
  -0.0194 * dat_pheno$Lymph

# 死亡风险得分
mortality_score <- 1 - exp(-1.51714 * exp(xb) / 0.0076927)

# 表型年龄 Phenotypic Age
PhenoAge <- 141.50 + log(-0.00553 * log(1 - mortality_score)) / 0.090165

dat_pheno$PhenoAge <- PhenoAge

cat("Phenotypic Age 的前10个值:\n")
head(dat_pheno[, c("id", "age", "PhenoAge")], 10)

# 年龄统计摘要
cat("\n实际年龄统计:\n")
summary(dat_pheno$age)

cat("\nPhenotypic Age 统计:\n")
summary(dat_pheno$PhenoAge)

# 画图
plot(dat_pheno$age, dat_pheno$PhenoAge,
     xlab = "实际年龄",
     ylab = "Phenotypic Age",
     main = "实际年龄 vs Phenotypic Age",
     col = rgb(0.8, 0.4, 0.2, 0.5), pch = 19)
abline(0, 1, col = "red", lwd = 2)
grid()
```

### 2.3 Phenotypic Age 加速情况

```{r phenotypic-acceleration, echo=TRUE}
dat_pheno$PhenoAge_high <- ifelse(dat_pheno$PhenoAge > dat_pheno$age, 1, 0)

cat("Phenotypic Age 高于实际年龄的比例:\n")
table(dat_pheno$PhenoAge_high)
prop.table(table(dat_pheno$PhenoAge_high)) * 100
```

## 3. 结果比较

```{r comparison, echo=TRUE}
# 合并两种方法的计算结果（注意：这里只是演示，实际使用的是两个独立的数据集）
cat("KDM 方法：\n")
cat("生物学年龄高于实际年龄的比例:", 
    round(mean(dat_kdm$BA_high) * 100, 2), "%\n")

cat("\nPhenotypic Age 方法：\n")
cat("生物学年龄高于实际年龄的比例:", 
    round(mean(dat_pheno$PhenoAge_high) * 100, 2), "%\n")

# 两种方法的年龄相关性
cat("\nKDM 生物学年龄与实际年龄的相关性:\n")
cor_kdm <- cor(dat_kdm$age, dat_kdm$BA_KDM)
print(cor_kdm)

cat("\nPhenotypic Age 与实际年龄的相关性:\n")
cor_pheno <- cor(dat_pheno$age, dat_pheno$PhenoAge)
print(cor_pheno)
```

## 总结

本文档展示了两种计算生物学年龄的方法：

1. **KDM 方法**：
   - 基于多个生物指标的线性回归
   - 使用统计方法推导每个指标的权重
   - 结果与实际年龄高度相关

2. **Phenotypic Age 方法**：
   - 基于 Levine (2018) 提出的公式
   - 包含 9 个临床指标
   - 与 10 年死亡风险相关

两种方法都能有效评估生物学年龄，可以用于研究衰老相关的过程。

*注意：本文档中的模拟数据仅供演示使用，实际应用中需要真实数据。*